from typing import List, Dict, Callable, Optional
from openai import OpenAI
from pydantic import BaseModel


class ConversationMessage(BaseModel):
    content: Optional[str] = None
    """The contents of the message."""

    refusal: Optional[str] = None
    """The refusal message generated by the model."""

    role: str
    """The role of the author of this message."""

    audio: Optional[dict] = None
    """Optional audio data for the message."""

    function_call: Optional[dict] = None
    """Deprecated. Function calls generated by the model."""

    tool_calls: Optional[List[dict]] = None
    """Tool calls generated by the model."""

    tool_call_id: Optional[str] = None
    """The ID of the tool call."""

def openai_summarizer(messages: List[Dict]) -> Dict:
    """
    Use OpenAI's API to summarize a list of messages.

    :param messages: List of messages to summarize.
    :return: A summary message as a dictionary.
    """
    content = "\n".join(f"{msg.role}: {msg.content}" for msg in messages if msg.content)

    client = OpenAI()
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=[{
            "role": "user",
            "content": f"Summarize the following conversation using the same language:\n{content}\n\nSummary:"
            }
        ]
    )

    summary_text = response.choices[0].message.content
    return ConversationMessage(role = "assistant", content = summary_text)

class ChatMemory:
    """
    A class to manage short-term and medium-term memory for an LLM-based chatbot.

    Short-term memory is a list of messages, where each message is a ChatCompletionMessage.
    Medium-term memory is managed by summarizing messages when a word limit is exceeded.
    """

    def __init__(self, word_limit: int, summarizer: Callable[[List[ConversationMessage]], ConversationMessage] = openai_summarizer, n_recent: int = 10):
        """
        Initialize the ChatMemory instance.

        :param word_limit: Maximum number of words allowed in short-term memory before summarization.
        :param summarizer: A callable that takes a list of messages and returns a summary message.
        :param n_recent: Number of most recent messages to preserve without summarizing.
        """
        self.word_limit = word_limit
        self.summarizer = summarizer
        self.n_recent = n_recent
        self.messages: List[ConversationMessage] = []

    def _count_words(self, text: str) -> int:
        """
        Count the number of words in a given text.

        :param text: The text to count words in.
        :return: The word count.
        """
        return len(text.split())

    def _total_word_count(self) -> int:
        """
        Calculate the total word count of all messages in the memory.

        :return: Total word count.
        """
        return sum(self._count_words(msg.content or "") for msg in self.messages)

    def add_message(self, message: ConversationMessage) -> None:
        """
        Add a new message to the memory. Summarize if the word limit is exceeded.

        :param message: The message to add, as a ChatCompletionMessage instance.
        """
        # f message is a dictionary, convert it to a ChatCompletionMessage instance
        if isinstance(message, dict):
            message = ConversationMessage(**message)

        self.messages.append(message)
        
        # Check if summarization is needed
        if self._total_word_count() > self.word_limit:
            # self._summarize_memory()
            pass

    def _summarize_memory(self) -> None:
        """
        Summarize the memory up to the most recent N messages, ensuring the resulting list size
        stays within the word limit. If necessary, reduce the number of recent messages preserved.
        """
        # Identify the last 'system' message
        last_system_index = next((i for i, msg in enumerate(self.messages) if msg.role == "system" or msg.role == "developer"), -1)

        if last_system_index == -1:
            raise ValueError("No 'system' message found in memory.")

        system_message = self.messages[last_system_index]

        for n in range(self.n_recent, 0, -1):
            recent_messages = self.messages[-n:]
            messages_to_summarize = self.messages[last_system_index + 1: -n]

            # Separate non-summarizable messages
            non_summarizable = [msg for msg in messages_to_summarize if msg.tool_calls is not None]
            summarizable = [msg for msg in messages_to_summarize if msg.tool_calls is None]

            if summarizable:
                # Summarize the messages
                summary = self.summarizer(summarizable)

                # Rebuild the memory: system message, non-summarizable, summary, and recent messages
                self.messages = [system_message] + non_summarizable + [summary] + recent_messages

                # Check if the total word count is within the limit
                if self._total_word_count() <= self.word_limit:
                    return

        # If no configuration works, keep only the system message and the last few messages
        self.messages = [system_message] + self.messages[-self.n_recent:]

    def get_memory(self) -> List[ConversationMessage]:
        """
        Get the current list of messages in the memory.

        :return: List of ChatCompletionMessage instances.
        """
        return self.messages



# Example usage
if __name__ == "__main__":
    # Initialize ChatMemory
    memory = ChatMemory(word_limit=30, summarizer=openai_summarizer, n_recent=2)

    # Add some messages
    memory.add_message(ConversationMessage(role="system", content="System initialization message."))
    memory.add_message(ConversationMessage(role="user", content="Hello, how are you?"))
    memory.add_message(ConversationMessage(role="assistant", content="I am fine, thank you for asking!"))
    memory.add_message(ConversationMessage(role="tools", content="Running diagnostic tool version 2.1."))
    memory.add_message(ConversationMessage(role="user", content="Can you help me with a problem I have?"))
    memory.add_message(ConversationMessage(role="assistant", content="Of course! Please provide more details about your issue."))
    memory.add_message(ConversationMessage(role="user", content="It is about an error in my code."))

    # Check memory content
    print(memory.get_memory())

